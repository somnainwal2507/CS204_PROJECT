# RISC-V Assembler

A simple assembler project developed for the Computer Architecture course. This tool translates RISC-V assembly language into machine code, demonstrating key principles in instruction translation and computer organization.

---

## Table of Contents

- [Overview](#overview)
- [Usage](#usage)
  - [Prerequisites](#prerequisites)
  - [Compilation](#compilation)
  - [Running the Assembler](#running-the-assembler)
- [Limitations](#limitations)
- [Further Scope of Improvement](#further-scope-of-improvement)
- [About Us](#about-us)


---

## Overview

This project takes an assembly file (`input.asm`) containing RISC-V code as input and produces a machine code file (`output.mc`) as output. The code is modularly divided into three main files:
- **format.cpp:** Handles the formatting and conversion logic for assembly instructions.
- **lookup.cpp:** Manages the opcode and instruction lookup functionality.
- **main.cpp:** Serves as the entry point and integrates all modules to perform the assembly process.

---

## Usage

### Prerequisites

- **C++ Compiler:** Ensure you have a C++ compiler installed (e.g., `g++` or `clang++`).
- **Command Line Usage:** Basic knowledge of terminal commands to compile and run the project.
- **bits/std++ Library:** This project requires the `bits/std++` library to be available. It is typically included in most modern C++ standard library distributions.


### Compilation

1. Open your terminal and navigate to the project directory.
2. Compile the source files using the following command:

   ```bash
      g++ main.cpp -o assembler
    ```
### Running the Assembler
1. Run the compiled executable:

   ```bash
      ./assembler
    ```
2. The program will read the `input.asm` file and generate the corresponding machine code in `output.mc`.

---

## Limitations
- `label :` is not supported as a label. It should be of the form `label:`
- There should be a space after `label: `.
- `.data:` and `.text:` are not supported. They should come without the colon as `.data` and `.text`.

---

## Further Scope of Improvement

We can implement a proper lexer which can tokenize the input code in a much more systematic manner. This will help in handling edge cases and errors more efficiently.

---

## Instruction Execution Simulator

An additional component, implemented in instruction_execution.cpp, has been added to the project. This simulator is designed to execute the machine code generated by the assembler. Its features include:
- **Five-Stage Pipeline Simulation:**
  The simulator models the following stages:

  - **Fetch:** Reads the instruction from the instruction memory.

  - **Decode:** Parses the instruction to identify the opcode, registers, and immediate values.

  - **Execute:** Performs the operation (e.g., arithmetic, logical, branch) according to the instruction.

  - **Memory Access:** Handles load and store instructions by reading from or writing to the data memory.

  - **Write Back:** Updates the destination register with the result from the execution or memory stage.
- **Logging and Debugging:**
  Detailed logs are generated for each clock cycle, including:
  - Register change events.
  - Memory change events.
  - Pipeline stage outputs.
- **File Outputs:**
  The simulator writes its output to several files:
  - `simulator_log.txt` – A comprehensive log of all simulation steps.
  - `register_log.mc` – A record of register updates during simulation.
  - `memory_log.mc` – A record of memory updates during simulation.
  - `final_state.mc` – The final state of all registers after simulation.
  - `final_data.mc` – The final state of updated memory addresses.
- **Usage:**
  Compile the simulator with your C++ compiler alongside the assembler. It reads the machine code from output.mc and simulates the execution of the instructions.

---

## About Us
- Atharva Mahajan (2023CSB1104)
- Nachiket Avachat (2023CSB1106)
- Som Nainwal (2023CSB1163)
